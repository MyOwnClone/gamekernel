\documentclass[chapter,kosection, 10.5pt, romanfixed, a4paper]{oblivoir}
\usepackage{fapapersize}
\usefapapersize{210mm,297mm,14mm,*,14mm,14mm}
\usepackage[usenames,dvipsnames]{color}
\usepackage[pdftex]{graphicx}
\usepackage{fancybox}

\SelectHfonts{utgr,utbm,utpg}{utyt,utgt,utgt}
\SetHangulspace{1.5}{1.2}
\addtolength{\droptitle}{-8ex}

\newenvironment{smallquote}
{\begin{quote}\small} {\end{quote}}

\begin{document}

\title{프로그래밍 온라인 게임}
\author{darkface}
\maketitle

\begin{quote}
\flushright \footnotesize
컴퓨터 프로그래밍은 시나 음악의 창작과 같은 예술의 형식이다. \\
- 도날드 크누스
\end{quote}
\qquad

\tableofcontents

\oblivoirchapterstyle{openright}
\chapter{긴 여정의 시작}

이제 프로그래머로서 온라인 게임을 만드는 긴 과정으로 들어가 봅니다. 그 간의 경험이 일천하여 
정리될 내용이 있을까 싶기도 하지만 스스로 공부하는 삼아 추가적인 테스트와 코드를 겸하여 
진행하고자 합니다. 

이 책을 쓰면서 전에 작성한 네트워크 엔진을 시뮬레이션을 구현한 서버 엔진으로 발전시키고 
테스트를 겸해서 클라이언트 엔진을 하나 만들려고 합니다. 여러 종류의 게임을 잘 만들고 싶고 
전체 구조가 안정적이어서 프로그래머는 고생하지 않고 기획자는 만족하고 그래픽은 펑펑 내용을 
쏟아 내고 사용자는 행복한 기술 기반을 만들려고 하는 게 제 남은 인생 동안 가려고 하는 길입니다. 
\\
\\
\textcolor{RoyalBlue}{자 이제 긴 여행을 시작해 봅시다.}

\section{게임 구조의 이해}

게임은 컴퓨터에서 창조된 세계를 표현합니다. 텍스트, 이미지, 사운드 등이 최종적인 
표현의 산출물입니다. 따라서, 게임을 만들 때는 창조된 세계와 표현 두 가지를 구현해야 합니다. 

창조된 세계는 가상 현실과 비슷한 개념이지만 상상력 만으로 제한 받는 세계이기 때문에 
더욱 넓은 개념이고 어찌 보면 끝이 없기 때문에 게임 개발을 매력적으로 만드는 이유입니다. 

\subsection{창조된 세계}

\shadowbox{창조된 세계는 오브젝트와 오브젝트 간의 상호 작용의 집합이다}

오브젝트는 마땅히 정의할 말이 없습니다. 우리가 있다고 믿는 어떤 것인데 결국은 상호 작용을 
통해서만 존재가 드러납니다. 하지만 일정하게 반응하기 때문에 우리가 알게 되는 것들입니다. 
상호 작용이 존재 자체의 근거가 된다는 점은 양자 역학의 불확정성 원리로도 알 수 있습니다. 

\begin{smallquote}
불확정성원리(Uncertainty principle) 는 양자 역학에서 맞바꿈 관측량(commuting observables)이 아닌 두 개의 
관측가능량(observable)을 동시에 측정할 때, 둘 사이의 정확도에는 물리적 한계가 있다는 원리이다. 
불확정성 원리는 양자역학에 대한 추가적인 가정이 아니고 양자역학의 통계적 해석으로부터 얻어진 근본적인 결과이다. 
하이젠베르크의 불확정성원리는 위치-운동량에 대한 불확정성원리이며, 입자의 위치와 운동량을 동시에 정확히 
측정할 수 없다는 것을 뜻한다. 위치가 정확하게 측정될 수록 운동량의 퍼짐(또는 불확정도)는 커지게 되고 
반대로 운동량이 정확하게 측정될 수록 위치의 불확정도는 커지게 된다.
\end{smallquote}

결국 창조된 세계에서 가장 중요한 것은 상호 작용입니다. 이를 통해서만 경험할 수 있고 믿을 수 있고 
뭔가가 있다고 생각합니다. 

\subsection{표현}

상호 작용은 관측될 수 있어야 합니다. 표현되지 않으면 알 수 없기 때문입니다. 표현은 게임에서 
더 중요한 작용을 합니다. 재미있다고 생각하고 현실처럼 생각합니다. 즉, 몰입할 수 있게 해줍니다. 

표현은 아직 오감 중 시각과 청각이 주가 되고 키보드나 마우스를 사용하면서 일부 촉각을 사용합니다. 
청각 표현은 이미 어느 정도 원하는 만큼 표현 가능한 수준에 도달했습니다. 하지만 아직 시각적인 표현은 
무궁무진하게 남아 있습니다. 물론 청각도 언제 어떻게 표현하냐에 따라 정말 새로운 느낌의 세계를 
만들 수 있습니다. 소리만으로 진행되는 게임도 가능하겠지요. 옛날 라디오 드라마 처럼요. 

\subsubsection{사실감}

\subsubsection{일관성}

\subsubsection{몰입}


\subsection{상호작용}

이제 게임은 어떤 상호작용이 가능한가와 이를 어떻게 표현하는가가 가장 중요한 기술과 기획적인 요소가 된다는
사실을 알았습니다. 영화처럼 그림만 보여주는 이야기 방식과 게임을 근본적으로 다르게 만든다는 점에서 
상호작용이 가장 중요합니다. 

\shadowbox{게임은 상호작용과 표현의 구조이다}

게임 기획자들은 저처럼 생각하지는 않을 겁니다. 그런 기획자는 혼나야 하겠지요. 하지만 프로그래머라면
이렇게 근본이 되는 구조를 파악하고 이해해야 합니다. 


\chapter{3D 엔진의 구현과 사용}

2D 엔진으로는 게임을 성공시킬 수 없는가하면 절대로 그렇지는 않다. 던전앤파이터나 메이플 스토리는
여전히 장수하고 있는 게임이며 바둑, 포커 등의 보드 게임도 아주 큰 시장을 형성하고 있다. 

하지만 이런 2D 게임들도 3D를 사용하여 구현하고 있으며 이미지의 사용량이 적어 개발이 보다 쉽고 
표현에 제약이 적다는 점에서 3D가 대세라고 봐야 한다. 

3D 엔진은 렌더링, 애니메이션, 이펙트, 물리 처리, 사운드 플레이를 포괄하는 광범위한 영역을 
포괄한다. 모든 기능을 다 내부 스튜디오에서 개발하기는 어렵기 때문에 미들웨어를 포괄적으로 
활용하면서 표현과 시뮬레이션의 품질과 유연성에 집중하여 게임 개발을 하는 것이 좋다. 

여기서는 gamekernel (http://code.google.com/p/gamekernel)에서 테스트 용도로 작성 중인 
3D 엔진의 개발과 그간의 엔진 사용 경험을 중심으로 정리해 나간다. 

\section{상용 엔진의 기능}

현존하는 최고의 엔진은 Unreal 3이다. 물론 타 엔진들이 빠르게 따라오고 있긴 하나 기능의 
안정성, 다양성, 편의성에서 아직 차이는 있다. 

언리얼 엔진의 기능은 다음과 같이 나누어진다. (http://www.unrealtechnology.com 참조)
\begin{itemize}
\item 렌더링 
\item 애니메이션
\item 오디오 
\item 물리 
\item 게임 스크립팅
\item 확장 애니메이션 (Matinee)
\item 파티클 이펙트
\item 에디터 
\item 네트워킹
\end{itemize}

위와 같은 방대한 기능을 갖고 있으며 경쟁력 있는 게임을 만들기 위한 기반이 확실하게 갖추어져 있다. 
플러그인 형태로 제공되는 스피드트리, 스케일폼, 하복 등도 그 기능이 강력하여 언리얼 기반의 
사업 체계가 이미 강력하게 형성되어 있다. 

그렇다고 좌절할 필요는 없다. 에픽 게임즈가 오래된 회사이고 언리얼 엔진도 1998년 출시된 이후 
오랜 시간 동안 안정되기는 했지만 쉐이더 기반의 렌더링 기술이 보편화되고 있고 언리얼 엔진이 
특허를 많이 출허한 엔진이 아니라는 측면에서는 접근 가능하다. 단지, 오랜 시간의 인내와 
노력이 필요하다. 

\subsection{렌더링}

렌더링이 멀티 코어를 지원하는 쓰레드 기반 렌더링을 지원한다. 쓰레드를 잘 활용할 수 있는 
기능이 앞으로도 계속 중요하다. 쓰레드를 잘 활용하려면 락 처리를 줄여서 서로 분리된 
기능들의 동시성을 최고로 올리는 게 관건이다. 

컬링도 BSP나 포털 기반에서 하드웨어를 사용한 동적인 컬링으로 옮겨가고 있다. 
잘만 활용한다면 충분한 성능을 거의 대부분의 장면에 적용 가능하다. 여러 가지로 이유로 
옥트리와 k-d 트리와 같은 장면 분할 기법은 여전히 필요하다. 특히, 온라인 게임의 서버를
위해서는 반드시 필요하다. 따라서, 이런 장면 관리 기법을 적용할 수 있도록 개발해야 한다. 

렌더링은 매시, 라이팅, 텍스쳐 등을 픽셀로 변환하는 과정을 말한다. 렌더링 품질은 결국 라이팅 처리에
의해 좌우되며 기본 성능을 제공하면서 처리하는 게 필요하다. 

그래픽 하드웨어의 발전에 따라 GPU의 성능을 최대한 활용할 수 있는 방법이 필요하며 
게임의 특성에 따라 균형을 맞출 수 있는 방법이 있어야 한다. 

최근의 경향에 따른 렌더링 기능은 다음과 같다. 
\begin{itemize}
\item Occlusion 컬링
\item 상세한 캐릭터 라이팅 (노멀 맵, 여러 개의 라이팅 사용)
\item 상세한 그림자 처리 
\item Global illumination (PRT 기법의 확장)
\item Ambient occlusion (자기 차폐 그림자 처리)
\item 후 처리 효과들 (블러링, Depth of Field, Bloom 등)
\item 지형의 상세한 처리 (displacement map, lighting, LOD 등)
\end{itemize}

\subsection{애니메이션}

애니메이션은 어느 정도 안정된 기능으로 리서치도 멈추는 것으로 보인다. 
골격과 키프레임 기반의 애니가 모두 보편화되었으며 골격과 키프레임 모두에 대해 
LOD를 지원하는 게 필요하다. 특히 MMOG를 개발할 때는 더욱 중요하다. 

언리얼의 기능을 중심으로 보면 다음과 같은 기능이 필요하다. 
\begin{itemize}
\item 기본 골격, 키 프레임 애니와 LOD 지원
\item 블렌딩 
\item 노드별 애니 변경 (블렌딩 변경과 키 프레임 등의 변경)
\item 속성과 머티리얼 애니의 연결 (쉐이더 변경, 텍스처 변경, 텍스처 좌표 변경 등)
\item 애니메이션 피드백 (특정 프레임에 이벤트 연결)
\end{itemize}

\subsection{오디오}

오디오는 이미 fmod, OpenAL 등의 좋은 라이브러리들이 있다. 따라서, 이런 좋은
라이브러를 통합하여 게임에 활용 가능하게 하면 된다. 

\begin{itemize}
\item 3D 사운드, 돌비 사운드
\item 이벤트 연동 플레이 시스템 
\item 사운드 압축 기능 
\end{itemize}

\subsection{물리}

이전에 하복이 최고였다면 이제는 GPU를 활용하는  Nvidia의 PhysX가 대세이다. 
따라서, 잘 연동하는 게 중요하며 시뮬레이션과 표현에서 적절하게 분리하여 
적용할 수 있는 기법들이 더 필요하다. 

\subsection{이펙트}

파티클 기반의 이펙트와 애니메이션 기반의 이펙트가 있다. 파티클은 LOD를 
지원하는 게 필요하다. 애니메이션 기반의 이펙트를 강화하는 게 더 중요하며 
아도비의 에프터 이펙트 기능을 어느 정도 수용 가능한가가 더 중요하다. 

따라서, 에프터 이펙트에서 바로 게임에 익스포트 가능한 형태의 툴을 만들고 
파티클을 적절하게 섞어서 쓴다면 훌륭한 이펙트들을 만들 수 있다. 

\subsection{환경}

어디에도 나와 있지는 않지만 스피드 트리와 같이 대규모 자연 환경이나 
도시 환경과 같은 환경 자체를 빠르게 렌더링할 수 있는 기능이 필요하다. 
이 쪽은 특수하게 최적화 할 수 있는 기법들이 있기 때문이다. 


\section{테스트 엔진의 개발}

우리의 궁극적인 목적이 재미있는 새로운 게임의 제작에 있다면 결국 중요한 건 
몰입감 있는 재미있는 상호작용의 창조에 있다. 

물론 공개 엔진들이 많이 있긴 하지만 최고로 단순한 엔진을 하나 개발하여 다양한
시뮬레이션 모델을 테스트 해 보는 걸 목표로 했다. 렌더링, 애니메이션, 이펙트, 
파티클을 갖추고 PhysX와 OpenAL을 활용하여 물리와 사운드를 처리할 계획이다. 

\subsection{렌더링}

 
\chapter{서버 프레임워크}

\section{기반 구조}

MMOG (Massive Multiplayer Online Games)에서 요구하는 서버의 기반 구조가 
달성해야 할 목표는 다음과 같이 나누어 볼 수 있다. 

\begin{itemize}
\item 안정성 (Stability)
\item 성능 (Performance)
\item 확장성 (Scalability)
\item 빠른 동기화 (Synchronization)
\item 쉽고 빠른 개발
\end{itemize}

위 네 가지 목표를 달성하기 위한 기술은 시간에 따라 변화 발전하지만 현재까지 
리서치한 결과로는 다음과 같이 나누어 볼 수 있다. 

\begin{itemize}
\item 처리 구조 (Processing Model)
\item 통신 구조 (Communication Model)
\item 분산 구조 (Distribution Model)
\item 월드 구조 (World Model)
\item 시뮬레이션 구조 (Simulation Model)
\item 영속성 처리 구조 (Persistency Model)
\end{itemize}

각 영역별 과제와 해결 방향을 살펴보고 장단점을 비교 분석한다. 

\subsection{처리 구조}

서버의 처리 구조는 CPU 코어를 포함하여 16개 미만이 현재 일반적인 상황이다. 
다중 쓰레드를 사용하는 구조가 보편화되어 있으며 다중 쓰레드를 어떻게 
사용하는가에 따라 두 가지 정도로 나누어 생각할 수 있다. 

\subsubsection{대칭 구조}

대칭 구조란 여러 쓰레드가 월드의 부분을 동시에 실행하는 구조이다. 이런 접근 
방식은 항상 critical section에 대한 락을 걸어야 하며 락 충돌이 발생하면 
쓰레드 스위칭이 일어난다. 

대칭 구조는 다음과 같은 장점을 갖는다. 
\begin{itemize} 
\item 동시성을 최대한 올릴 수 있다
\item 데이터 복제나 이벤트 전파를 줄일 수 있다. 
\end{itemize}

하지만 다음과 같은 심각한 단점도 갖고 있다. 
\begin{itemize}
\item 락 처리가 까다로워진다. 
\item 코드 량이 늘어날수록, 시간이 지날수록 점점 느려진다.
\end{itemize}

대칭 구조의 장점을 유지하면서 락 처리를 프로그래머가 직접하지 않아도 
되는 구조에 대한 연구가 진행되고 있으며 DarkStar의 Java 서버 구현에서는
오브젝트에 대한 락을 미리 잡는 방식으로 피하고 있다. 하지만 엄청 느리다는
결정적인 단점이 있다. 

대칭 구조를 사용하여 여전히 개발하고 있으나 장기적으로 갖고 갈 방향은 아니라고 본다. 

\subsubsection{비대칭 구조}

비대칭 구조란 개별 쓰레드에서 처리하는 데이터, 월드를 분할하여 처리하는 
방식이다. 비대칭 구조는 메세지 패싱을 기본 아이디어로 삼고 있으며 이를 
계산 모델로 확립한 Actor 모델이 있다. Actor 모델은 분산 인공지능에 
적용된 Multi Agent System (MAS)의 기반 아이디어로 사용하고 있다. 

비대칭 구조로 MMOG를 만드는 것은 가능하며 다크에이지오브카멜롯, 메틴, 
썬 등에 사용되었고 넥슨의 둠바스도 이런 아이디어에 기초하고 있다. 

비대칭 구조의 장점은 다음과 같다. 
\begin{itemize}
\item 락 처리가 거의 필요 없다. (메세지 큐 정도에만 사용)
\item 시간이 지나도 성능이 떨어지지 않는다
\item 좀 더 세밀하게 분할하는 확장을 쉽게 할 수 있다
\end{itemize}

당연히 다음과 같은 단점도 있다. 
\begin{itemize}
\item 분할된 지역 기능에 대한 동시성을 올리기 어렵다
\item 각 분할 영역 간의 메세지, 데이터 전파가 필요하다
\end{itemize}

\subsubsection{처리 구조 정리}

DirectX11의 멀티 쓰레딩 구조나 기존의 쓰레드 기반 렌더러를 보면 command queue 방식을 
사용하고 있다. 렌더링 쓰레드, 물리 처리 쓰레드, 애플리케이션 쓰레드로 분할 하고 
각 쓰레드 간에 명령어를 주고 받아서 처리하는 방식이다. 

서버도 전체 월드를 지역별로 분할하고 각 지역을 좀 더 세분화 가능하게 만들고 
AI를 돌리는 쓰레드를 별도로 두는 방식으로 대칭 구조에 필적하는 성능을 
갖게 만들 수 있다. 

지금까지 경험으로 보면 이런 지역 분할 방식과 연계된 서버들은 모두 상당히 
안정적이며 유지보수도 쉽다. 

메세지 패싱을 사용하면 처리하는 쓰레드가 다른 장비에 있더라도 그대로 
적용 가능하기 때문에 가용한 CPU 수량을 늘리는 걸 거의 공짜로 할 수 있다. 

이런 장점을 활용하면 클라이언트 중의 하나가 특정 기능을 담당하도록 하는 
분산 기능도 쉽게 구현할 수 있다. 


\subsection{통신 구조}

통신은 이미 해결된 문제로 보인다. 지금까지 해결된 내용이 무엇인지만 
간결하게 살펴본다. 

\begin{itemize}
\item 대규모 통신 처리 지원 (IOCP, EPOLL, AIO 등)
\item TCP와 UDP 상의 통신 구조 
\item 패킷 암호화, 패킷 검증 (순서, 누락 등)
\item P2P 통신 처리 (홀 펀칭, Reliable UDP 등)
\end{itemize}

물론 게임을 만들다 보면 패치 시스템과 같은 전혀 다른 통신 구조를 
만들어야 하는 경우도 생긴다. 리소스 스트리밍은 게임 구현과는 
직접 연관이 없지만 서비스 품질을 올리는 데는 아주 중요하며 
서버 프로그래머가 클라이언트 프로그래머와 함께 해결해야 하는 과제이다. 

\subsection{분산 구조}

처리 구조와 어느 정도 연관되지만 서버의 장비들을 확장하거나 PC를 게임 
시뮬레이션에 직접적으로 활용하거나 (트래픽 전파나 물리 처리에 활용) 하는 
다른 차원의 분산 구조가 필요하다. 

일관성과 유일성을 보장해야 하는 길드 처리나 DB 처리는 한 곳에서 관리하는 게 
필요하다. 이런 기능들을 몰아두고 인증 정보 등을 관리하기 위한 구조로 대략
다음과 같은 서버 분산 구조를 채택한다. 

\begin{itemize}
\item 로비 서버를 두는 경우
\item 센터(백엔드) 서버를 두는 경우 
\item 역할별 서버를 두는 경우
\end{itemize}

로비를 앞 단에 두는 경우는 로비를 통해서만 게임 서버와 통신 하는 경우와 
로비가 단순 북 키핑 작업만 하는 경우가 있다. 통신을 중계하는 건 보안성이 
약간 더 올라가지만 통신 자체가 느려진다는 점에서 바람직해 보이지는 않는다. 
다크 에이지 오브 카멜롯의 경우 통신까지 중계하는 방식을 사용했다. 

센터를 두는 경우가 일반적인데 B\&B, 넥슨의 어둠시리즈까지의 게임들이 
이런 구조를 택했고 아주 많은 게임에서 주로 채택하고 있는 방식이기도 하다. 

역할별 서버를 두는 경우는 AI 서버나 로그인 서버, 커뮤니티 서버 등 큰 역할을
별도로 분리된 서버에 두는 방식의 일반적인 확장이다. 길드 컨텐츠나 여러 서버에
분산될 수 있는 파티의 경우 별도 커뮤니티 서버에서 북 키핑을 담당하는 걸 생각해 
볼 수 있으며 장점도 명확하다. AI 서버의 경우는 논란의 여지가 있다. 

\subsection{월드 구조}

MMORPG의 경우 클라이언트가 옥트리나 k-d 트리 또는 변형된 BSP 트리를 사용하여 
장면 그래프를 구성하기 때문에 클라이언트의 경우는 이들 구조를 반영하여 사용하면 된다. 

서버의 경우 시뮬레이션에서 물리적인 정확도가 점점 강조되면서 (논 타겟팅에서 특히 심함) 
충돌 처리를 통한 이동까지도 고려해야 하는 시대가 되었다. 따라서, 전체적인 구성을 
Octree나 쿼드 트리로 하고 여기에 네비게이션 매시와 지형의 속성 정보에 따른 길찾기가 
가능한 구조를 심은 후에 느슨한 충돌 처리 (박스 형태나 성긴 충돌 매시 등)를 하는 월드 
구조가 필요하다. 

처리 구조와 맞물려서 구성해야 하며 대칭형일 경우에는 락 충돌을 줄이는 구조가 필요하고
비대칭형 일 경우에는 인접 지역으로 빠르게 전파하며 전체 처리를 인원 수나 바쁜 정도에 
따라 쓰레드 배분이 가능한 구조가 필요하다. 

인스턴트 던전도 일반화되고 있기 때문에 여러 인던을 동시에 부드럽게 처리할 수 있는 구조도 
함께 고려하여 월드 데이터 구조를 초기부터 잡아야 한다. 

\subsection{시뮬레이션 구조}

전체적인 시뮬레이션 구조의 상위 구조는 Entity (또는 Actor ), 메세지 (또는 이벤트), 상태기계로
추상화 할 수 있다. 또한 데이터 클래스를 View (또는 Data)와 같은 이름으로 분리하여 처리와 
데이터를 확실하게 구분하면 패킷 처리나 클라이언트와 공유하는 부분에서 많은 이득을 볼 수 있다. 

각 처리 단위에서 메세지에 대한 subscription/dispatch 기능을 두고 타이머 기능까지 메세지로 
처리하면 서버 단위 기능 테스트를 메세지로 자동화 시킬 수 있다. 또한 연결을 찾아야만 하는 
구조를 사용하지 않으면 대규모 스트레스도 실제 서버의 데이터를 갖고 처리 가능하다. 

시뮬레이션에 대한 상세 구조는 시뮬레이션 절에서 좀 더 자세하게 살펴본다. 게임 기능이 
결국 통신과 처리 구조 상에서 시뮬레이션 기능으로 구현되기 때문에 가장 중요하고 AI와 
물리 처리와 더불어 서버의 가장한 중요한 영역이다. 

\subsection{영속성 처리 구조}

Persistence를 처리하기 위해 DBMS를 사용한다. 아주 오래 전에는 파일을 사용한 경우도 있었지만
SQL DB의 성능 향상으로 대부분의 게임들이 관계형 DB를 사용하고 있다. 

관계형 DB의 TPS가 실시간 업데이트를 처리할 정도로 빠르지는 않기 때문에 (물론 가능은 하다)
대부분 DB 처리를 위한 서버를 하나 두어 트랜잭션을 조절하는 형태로 사용하고 있다. 

DB 서버에 캐싱 기능을 두면 성능은 많이 빨라지기는 하나 운영을 위한 툴 작업에 어려움을 
겪게 된다. 따라서, 이를 염두에 두고 캐시 서버를 작업해야 한다. 

몇 가지 캐싱 가능한 영역은 플레이어 추가 정보 (비밀 번호 제외), 인벤토리, 스킬 정보 등이 
있으며 이 쪽 테이블에 변경이 발생할 경우 게임에 접속 중인 사용자의 정보를 다시 로딩할 수 있는
방법이 필요하다 (운영 툴용 클라이언트).


\section{시뮬레이션}

서버 시뮬레이션은 두 가지 영역으로 나누어진다. 물리적인 시뮬레이션과 논리적인 시뮬레이션. 
물리적인 시뮬레이션은 MMORPG에서 점점 더 강조되는 영역이며 논리적인 시뮬레이션은 밸런스를
포함하여 전통적으로 MMORPG가 돈을 벌 수 있도록 한 영역이다. 두 가지 다 중요하고 새로운 모델을
찾아 나가는 것이 필요하다. 

\subsection{물리 기반의 월드}

물리 기반의 월드는 모든 MMORPG의 기반이 되는 이동의 핵심이다. 미사일이나 화살과 같이 
궤적이 있는 물체의 이동에도 물리적인 시뮬레이션을 사용하는 게 보편화되고 있기 때문에 
물리 충돌도 점점 중요하게 된다. 

\subsubsection{이동}

지형의 구조에 따라 다르긴 하지만 높이 기반의 일반적인 지형이라면 지형 속성 비트맵을
많이 사용한다. 속성에 따라 갈 수 없는 곳 등의 속성 표시가 가능. 해상도가 낮아지기 때문에
NPC의 경우에는 네비게이션 매시나 웨이 포인트 기능을 추가해야 한다. 

\subsubsection{탄도, 충돌}

서버에서는 클라이언트처럼 충돌을 상세하게 처리하기 어렵다. 따라서, 클라이언트를 서버 
시뮬레이션에 참여하도록 하여 상세한 충돌이나 이동을 처리하도록 하는 게 궁극적으로 
가야 할 구조로 보인다. 이렇게 할 경우 해킹 등에 대한 대처가 필요하나 서버에서 
느슨한 검증을 하고 참여 클라이언트를 파악하기 어렵도록 하며 일부의 시뮬레이션만
담당하도록 하여 조절할 수 있다. 

충돌 매시나 충돌 박스, 충돌 구를 서버에서 월드 구조로 갖고 있어야 한다. 이 구조는 
레벨 에디터에서 만들어져야 하고 네비게이션 매시, 웨이포인트, AI 특성 편집과 함께 
이루어지도록 해야 한다. 

\subsubsection{동기화}

물리 세계의 동기화는 상세하게 하려면 비용이 많이 든다. 동기화의 기본적인 알고리즘은
이벤트 동기화와 상태 동기화 두 가지가 있다. 대부분의 게임 서버에서는 이벤트 동기화를
사용하며 다옥 등 일부 게임에서는 이동의 상태 동기화를 하기도 한다. 

상태 동기화는 상세한 동기화가 가능하나 패킷량이 증가하기 때문에 이벤트 동기화와 
적절하게 균형을 잡아 가는 게 필요하다. 

\subsection{논리 기반의 월드}

서버의 대부분의 컨텐츠는 논리 기반의 시뮬에이션이다. 왜냐하면 물리세계의 동기화나 
시뮬레이션 계산량이 아직은 장비들에서 게임이 재미있을만큼 수용하기 어렵기 때문이다.

결국 아이템 판매나 캐릭터 판매와 같은 MMORPG의 핵심 유료화 모델이 동작하려면 
표현의 상세한 처리와 함께 밸런스 위주의 다양한 컨텐츠로서 동작하는 논리 기반의 
월드가 잘 구성되어야 한다. 

\chapter{온라인 게임 Construction}

\section{프로그래밍 일반}

\subsection{진행}

설계, 구현, 테스트의 일반적인 흐름이 실제로는 잘 동작하지 않는다. 물론 이 과정이 있어야 하지만
길고 큰 시스템 단위로는 동작하지 않는다. Extreme programming이 제안하는 바는 작은 단위로 
위 과정을 반복하라는 것이다. 변경도 좀 더 빠르게 반영될 수 있도록 하고 사용자에게 제공되는 
가치 중심으로 작업한다는 뜻이며 단위 테스트와 리팩터링이 가장 강력한 수단이 된다. 

\subsection{읽히는 코드}

도날드 누쓰의 literate programming은 문서와 코드를 함께 작성하는 구조이다. 게임 프로그래밍을 
이렇게 할 수는 없고 미리 주석으로 골격을 만든 후 작성 후에 정리하는 방식으로 진행할 수는 있다. 

읽히는 코드 작성에서 가장 중요한 점은 동작하는 코드에서 관심을 쉽게 이해할 수 있는 코드로 
옮겨야 한다는 점이다. 이렇게 했을 때 여러 가지 버그도 쉽게 줄일 수 있고 유지보수도 가능하며 
설계가 좀 더 나은 구조를 만들어내기가 보다 수월하다. 

읽히는 코드는 유닛 테스트와도 밀접한 관계가 있다. 사용 방식이 미리 정해진 코드는 구현에만 
신경 쓴 코드보다 훨씬 이해하기가 쉽다. 유닛 테스트는 이런 사용자와 사용 코드의 관계를 형성하여 
설계를 보다 개선하고 코딩도 간결하게 하는 데 큰 역할을 한다. 

\subsection{게으름}

너무 빨리 너무 부지런히 코딩하는 건 좋지 않다. 그리고 많은 양의 코드로 원하는 목표를 달성하는 것보다는
데이터로 내용을 채우고 코드 구조는 간결하게 가져가는 게 좋다. 유지보수 과정이 아니라면 땜빵 보다는
보다 확실한 솔루션이나 알고리즘을 정리한 후에 코딩을 시작하는 게 좋다. 

\subsection{기본}

코딩 컨벤션이 있어야 한다. 설계와 관련된 컨벤션까지는 아니더라도 명명 규칙, 헤더의 구조, 
주석 구조, 블럭 구조, 자잘한 세부 사항에 대한 가이드 등이 필요하다. 

\subsection{반드시 읽어야 할 세 가지 분야}

디자인 패턴, 리팩터링, 유닛 테스트. 

\subsection{자잘하지만 중요한 것들}

서버 프로그래머로서 요구되는 것들은 아주 많다. 이 부분은 대부분 know-how 이거나, 하지 말아야 할 것들, 
꼭 해야 할 것들 등이 있을 수 있다. 각 회사마다 이런 내용을 구체적인 기술과 함께 
오랜 시간 잘 정리해 나가는 게 필요하다. 
 
\section{게임 서버 프레임워크}

아래 세 가지로 충분하다고 할 수는 없지만 다른 문제들은 이미 많이 해결되었기 때문에 
핵심으로 생각하는 내용만 정리한다. 

\subsection{Entity, Message, 계층 구조}

Communicating sequential process에서 시작된 액터 모델은 병렬 처리 프로그래밍에 많은 영향을 미쳤고 
Multiagent System의 초석이 되었다. 

많은 게임에서 이미 Entity, Message 구조를 사용하고 있으며 HFSM이나 HCSM 또는 행동 트리와 같은 
계층 구조를 사용하고 있다. HCSM과 행동 트리는 서로 보완하면서 사용할 수 있다. 

전체 프레임워크를 Entity, Message, HCSM으로 구성하고 세부 조절을 행동 트리로 진행하는 방식이 프레임워크에는
더 적당한 것으로 보인다. 행동 트리는 상세한 AI (몬스터 AI) 등 특수한 Entity에 적용하는 게 더 나아 보이지만 
행동 트리에 대해서는 좀 더 이해가 필요하다. 

\subsection{월드와 처리 구조의 바인딩}

월드를 돌릴 구조가 필요하다. 한 안으로 월드 전체를 Octree로 구성하고 적당한 크기의 Octree에 대해 
처리 쓰레드를 붙여서 (Cell이라고 부르자) 인접한 셀과 동기화를 처리하는 식으로 구성하면 충분하다. 

인던과 같은 구조는 인던을 돌리는 셀들을 만들어서 쓰레드 대신 몇 개의 셀을 한 쓰레드에서 돌리는 방식으로
구성 가능하다. 물론 CPU가 더 필요하다면 게임에 맞게 구성할 수 있다. 

\subsection{아주 많은 옵션과 변화하는 기능 처리}

요즘은 어지간한 게임은 모두 캐릭터랑 스킬 수십개를 넘어 수백개에 근접한다. 캐릭터 종류도 많아지고
또 아이템도 다양하게 많다. 아이템에 붙는 옵션도 많고 공방이나 갬블 등을 통해 옵션을 붙이거나 
슬롯에 또 다른 아이템을 붙이거나 하는 식으로 아주 복잡한 속성을 다양하게 갖는다. 

이런 기능이 고정되어 있다면 프로그래머 입장에서는 다행이겠지만 서비스를 시작하거나 그 이전부터 
계속 추가/삭제/변경이 이루어진다. 이런 변경은 한 부분에 머물지 않고 게임 전체에 번진다. 이런 복잡함과 
변화에 대응하기 위한 구조와 처리 방법이 지속적인 컨텐츠 추가와 개발의 안정성으로 돌아온다. 성공하고 
있을 때 더욱 중요해진다. 

\subsubsection{일단 하는 게 더 중요하다}

기획에서 원하고 사용자들이 원하는 세밀한 조율, 변경, 다양한 기능은 반드시 해야 한다. 코드가 다소 지저분해지고
구현이 복잡해 지면서 프로그래머로서는 하고 싶지 않은 일이라고 하더라도 꼭 해야 한다. 이 점을 명심하는 게 
시작이다. 

\subsubsection{반드시 해야 한다면 잘 해야 한다}

이런 변화에 대응하기 위한 방법이 개별 컨텐츠별로 좀 차이가 있다. 이런 변경을 아이템, 스킬 등 세부 항목을 
살펴볼 때 더 정리해 나가도록 한다. 


\section{온라인 게임의 컨텐츠 구성 패턴}

온라인 게임의 기능과 동작을 패턴화 하려는 본격적인 노력은 아직 보지 못 했다. 따라서, 여기서 시도하는 
바는 실험적이며 발전시켜야 한다. 몇 가지 고려해야 할 점들을 먼저 살펴보자. 

\subsection{패턴화의 방향}

디자인 패턴은 정적인 클래스 구조를 기반으로 하여 협력 관계를 보여주는 것으로 완성한다. 샘플 코드도 
제시한다. 온라인 게임은 아주 많고 공통된 필드들도 있지만 독창성 자체가 상품의 가치이다 보니 아주 
다른 특성들을 갖는 경우도 많다. 



\subsection{아이템}



\subsection{인벤토리}





\section{인공 지능}

\subsection{이동과 A*}

\subsection{전투}

\subsection{확률 요소}



\section{테스트 프레임워크}

\subsection{단위 테스트}

\subsection{기능 테스트}

\subsection{스트레스 테스트}

\subsection{밸런스 테스트}


\section{운영 기능}

\subsection{버그 리포팅}

\subsection{서버 설치와 자동 패치}

\subsection{이벤트 로깅과 리포트}

\subsubsection{아이템 트래킹}

\subsubsection{플레이 패턴}

\subsubsection{Revenue Analysis}

\subsection{관리 콘솔}



\end{document}