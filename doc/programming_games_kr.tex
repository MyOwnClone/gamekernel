\documentclass[chapter,kosection, 10.5pt, romanfixed, a4paper]{oblivoir}
\usepackage{fapapersize}
\usefapapersize{210mm,297mm,10mm,*,10mm,10mm}
\usepackage[usenames,dvipsnames]{color}
\usepackage[pdftex]{graphicx}
\usepackage{fancybox}

\SelectHfonts{utbm,utbm,utpg}{utyt,utgt,utgt}
\SetHangulspace{1.5}{1.2}
\addtolength{\droptitle}{-8ex}

\newenvironment{smallquote}
{\begin{quote}\small} {\end{quote}}


\begin{document}

\title{프로그래밍 온라인 게임}
\author{darkface}
\maketitle

\begin{quote}
\flushright \footnotesize
컴퓨터 프로그래밍은 시나 음악의 창작과 같은 예술의 형식이다. \\
- 도날드 크누스
\end{quote}
\qquad

\tableofcontents

\oblivoirchapterstyle{openright}
\chapter{긴 여정의 시작}

이제 프로그래머로서 온라인 게임을 만드는 긴 과정으로 들어가 봅니다. 그 간의 경험이 일천하여 
정리될 내용이 있을까 싶기도 하지만 스스로 공부하는 삼아 추가적인 테스트와 코드를 겸하여 
진행하고자 합니다. 

이 책을 쓰면서 전에 작성한 네트워크 엔진을 시뮬레이션을 구현한 서버 엔진으로 발전시키고 
테스트를 겸해서 클라이언트 엔진을 하나 만들려고 합니다. 여러 종류의 게임을 잘 만들고 싶고 
전체 구조가 안정적이어서 프로그래머는 고생하지 않고 기획자는 만족하고 그래픽은 펑펑 내용을 
쏟아 내고 사용자는 행복한 기술 기반을 만들려고 하는 게 제 남은 인생 동안 가려고 하는 길입니다. 
\\
\\
\textcolor{RoyalBlue}{자 이제 긴 여행을 시작해 봅시다.}

\section{게임 구조의 이해}

게임은 컴퓨터에서 창조된 세계를 표현합니다. 텍스트, 이미지, 사운드 등이 최종적인 
표현의 산출물입니다. 따라서, 게임을 만들 때는 창조된 세계와 표현 두 가지를 구현해야 합니다. 

창조된 세계는 가상 현실과 비슷한 개념이지만 상상력 만으로 제한 받는 세계이기 때문에 
더욱 넓은 개념이고 어찌 보면 끝이 없기 때문에 게임 개발을 매력적으로 만드는 이유입니다. 

\subsection{창조된 세계}

\shadowbox{창조된 세계는 오브젝트와 오브젝트 간의 상호 작용의 집합이다}

오브젝트는 마땅히 정의할 말이 없습니다. 우리가 있다고 믿는 어떤 것인데 결국은 상호 작용을 
통해서만 존재가 드러납니다. 하지만 일정하게 반응하기 때문에 우리가 알게 되는 것들입니다. 
상호 작용이 존재 자체의 근거가 된다는 점은 양자 역학의 불확정성 원리로도 알 수 있습니다. 

\begin{smallquote}
불확정성원리(Uncertainty principle) 는 양자 역학에서 맞바꿈 관측량(commuting observables)이 아닌 두 개의 
관측가능량(observable)을 동시에 측정할 때, 둘 사이의 정확도에는 물리적 한계가 있다는 원리이다. 
불확정성 원리는 양자역학에 대한 추가적인 가정이 아니고 양자역학의 통계적 해석으로부터 얻어진 근본적인 결과이다. 
하이젠베르크의 불확정성원리는 위치-운동량에 대한 불확정성원리이며, 입자의 위치와 운동량을 동시에 정확히 
측정할 수 없다는 것을 뜻한다. 위치가 정확하게 측정될 수록 운동량의 퍼짐(또는 불확정도)는 커지게 되고 
반대로 운동량이 정확하게 측정될 수록 위치의 불확정도는 커지게 된다.
\end{smallquote}

결국 창조된 세계에서 가장 중요한 것은 상호 작용입니다. 이를 통해서만 경험할 수 있고 믿을 수 있고 
뭔가가 있다고 생각합니다. 

\subsection{표현}

상호 작용은 관측될 수 있어야 합니다. 표현되지 않으면 알 수 없기 때문입니다. 표현은 게임에서 
더 중요한 작용을 합니다. 재미있다고 생각하고 현실처럼 생각합니다. 즉, 몰입할 수 있게 해줍니다. 

표현은 아직 오감 중 시각과 청각이 주가 되고 키보드나 마우스를 사용하면서 일부 촉각을 사용합니다. 
청각 표현은 이미 어느 정도 원하는 만큼 표현 가능한 수준에 도달했습니다. 하지만 아직 시각적인 표현은 
무궁무진하게 남아 있습니다. 물론 청각도 언제 어떻게 표현하냐에 따라 정말 새로운 느낌의 세계를 
만들 수 있습니다. 소리만으로 진행되는 게임도 가능하겠지요. 옛날 라디오 드라마 처럼요. 

\subsubsection{사실감}

\subsubsection{일관성}

\subsubsection{몰입}


\subsection{상호작용}

이제 게임은 어떤 상호작용이 가능한가와 이를 어떻게 표현하는가가 가장 중요한 기술과 기획적인 요소가 된다는
사실을 알았습니다. 영화처럼 그림만 보여주는 이야기 방식과 게임을 근본적으로 다르게 만든다는 점에서 
상호작용이 가장 중요합니다. 

\shadowbox{게임은 상호작용과 표현의 구조이다}

게임 기획자들은 저처럼 생각하지는 않을 겁니다. 그런 기획자는 혼나야 하겠지요. 하지만 프로그래머라면
이렇게 근본이 되는 구조를 파악하고 이해해야 합니다. 


\chapter{3D 엔진의 구현과 사용}

2D 엔진으로는 게임을 성공시킬 수 없는가하면 절대로 그렇지는 않다. 던전앤파이터나 메이플 스토리는
여전히 장수하고 있는 게임이며 바둑, 포커 등의 보드 게임도 아주 큰 시장을 형성하고 있다. 

하지만 이런 2D 게임들도 3D를 사용하여 구현하고 있으며 이미지의 사용량이 적어 개발이 보다 쉽고 
표현에 제약이 적다는 점에서 3D가 대세라고 봐야 한다. 

3D 엔진은 렌더링, 애니메이션, 이펙트, 물리 처리, 사운드 플레이를 포괄하는 광범위한 영역을 
포괄한다. 모든 기능을 다 내부 스튜디오에서 개발하기는 어렵기 때문에 미들웨어를 포괄적으로 
활용하면서 표현과 시뮬레이션의 품질과 유연성에 집중하여 게임 개발을 하는 것이 좋다. 

여기서는 gamekernel (http://code.google.com/p/gamekernel)에서 테스트 용도로 작성 중인 
3D 엔진의 개발과 그간의 엔진 사용 경험을 중심으로 정리해 나간다. 

\section{상용 엔진의 기능}

현존하는 최고의 엔진은 Unreal 3이다. 물론 타 엔진들이 빠르게 따라오고 있긴 하나 기능의 
안정성, 다양성, 편의성에서 아직 차이는 있다. 

언리얼 엔진의 기능은 다음과 같이 나누어진다. (http://www.unrealtechnology.com 참조)
\begin{itemize}
\item 렌더링 
\item 애니메이션
\item 오디오 
\item 물리 
\item 게임 스크립팅
\item 확장 애니메이션 (Matinee)
\item 파티클 이펙트
\item 에디터 
\item 네트워킹
\end{itemize}

위와 같은 방대한 기능을 갖고 있으며 경쟁력 있는 게임을 만들기 위한 기반이 확실하게 갖추어져 있다. 
플러그인 형태로 제공되는 스피드트리, 스케일폼, 하복 등도 그 기능이 강력하여 언리얼 기반의 
사업 체계가 이미 강력하게 형성되어 있다. 

그렇다고 좌절할 필요는 없다. 에픽 게임즈가 오래된 회사이고 언리얼 엔진도 1998년 출시된 이후 
오랜 시간 동안 안정되기는 했지만 쉐이더 기반의 렌더링 기술이 보편화되고 있고 언리얼 엔진이 
특허를 많이 출허한 엔진이 아니라는 측면에서는 접근 가능하다. 단지, 오랜 시간의 인내와 
노력이 필요하다. 

\subsection{렌더링}

렌더링이 멀티 코어를 지원하는 쓰레드 기반 렌더링을 지원한다. 쓰레드를 잘 활용할 수 있는 
기능이 앞으로도 계속 중요하다. 쓰레드를 잘 활용하려면 락 처리를 줄여서 서로 분리된 
기능들의 동시성을 최고로 올리는 게 관건이다. 

컬링도 BSP나 포털 기반에서 하드웨어를 사용한 동적인 컬링으로 옮겨가고 있다. 
잘만 활용한다면 충분한 성능을 거의 대부분의 장면에 적용 가능하다. 여러 가지로 이유로 
옥트리와 k-d 트리와 같은 장면 분할 기법은 여전히 필요하다. 특히, 온라인 게임의 서버를
위해서는 반드시 필요하다. 따라서, 이런 장면 관리 기법을 적용할 수 있도록 개발해야 한다. 

렌더링은 매시, 라이팅, 텍스쳐 등을 픽셀로 변환하는 과정을 말한다. 렌더링 품질은 결국 라이팅 처리에
의해 좌우되며 기본 성능을 제공하면서 처리하는 게 필요하다. 

그래픽 하드웨어의 발전에 따라 GPU의 성능을 최대한 활용할 수 있는 방법이 필요하며 
게임의 특성에 따라 균형을 맞출 수 있는 방법이 있어야 한다. 

최근의 경향에 따른 렌더링 기능은 다음과 같다. 
\begin{itemize}
\item Occlusion 컬링
\item 상세한 캐릭터 라이팅 (노멀 맵, 여러 개의 라이팅 사용)
\item 상세한 그림자 처리 
\item Global illumination (PRT 기법의 확장)
\item Ambient occlusion (자기 차폐 그림자 처리)
\item 후 처리 효과들 (블러링, Depth of Field, Bloom 등)
\item 지형의 상세한 처리 (displacement map, lighting, LOD 등)
\end{itemize}

\subsection{애니메이션}

애니메이션은 어느 정도 안정된 기능으로 리서치도 멈추는 것으로 보인다. 
골격과 키프레임 기반의 애니가 모두 보편화되었으며 골격과 키프레임 모두에 대해 
LOD를 지원하는 게 필요하다. 특히 MMOG를 개발할 때는 더욱 중요하다. 

언리얼의 기능을 중심으로 보면 다음과 같은 기능이 필요하다. 
\begin{itemize}
\item 기본 골격, 키 프레임 애니와 LOD 지원
\item 블렌딩 
\item 노드별 애니 변경 (블렌딩 변경과 키 프레임 등의 변경)
\item 속성과 머티리얼 애니의 연결 (쉐이더 변경, 텍스처 변경, 텍스처 좌표 변경 등)
\item 애니메이션 피드백 (특정 프레임에 이벤트 연결)
\end{itemize}

\subsection{오디오}

오디오는 이미 fmod, OpenAL 등의 좋은 라이브러리들이 있다. 따라서, 이런 좋은
라이브러를 통합하여 게임에 활용 가능하게 하면 된다. 

\begin{itemize}
\item 3D 사운드, 돌비 사운드
\item 이벤트 연동 플레이 시스템 
\item 사운드 압축 기능 
\end{itemize}

\subsection{물리}

이전에 하복이 최고였다면 이제는 GPU를 활용하는  Nvidia의 PhysX가 대세이다. 
따라서, 잘 연동하는 게 중요하며 시뮬레이션과 표현에서 적절하게 분리하여 
적용할 수 있는 기법들이 더 필요하다. 

\subsection{이펙트}

파티클 기반의 이펙트와 애니메이션 기반의 이펙트가 있다. 파티클은 LOD를 
지원하는 게 필요하다. 애니메이션 기반의 이펙트를 강화하는 게 더 중요하며 
아도비의 에프터 이펙트 기능을 어느 정도 수용 가능한가가 더 중요하다. 

따라서, 에프터 이펙트에서 바로 게임에 익스포트 가능한 형태의 툴을 만들고 
파티클을 적절하게 섞어서 쓴다면 훌륭한 이펙트들을 만들 수 있다. 

\subsection{환경}

어디에도 나와 있지는 않지만 스피드 트리와 같이 대규모 자연 환경이나 
도시 환경과 같은 환경 자체를 빠르게 렌더링할 수 있는 기능이 필요하다. 
이 쪽은 특수하게 최적화 할 수 있는 기법들이 있기 때문이다. 


\section{테스트 엔진의 개발}

우리의 궁극적인 목적이 재미있는 새로운 게임의 제작에 있다면 결국 중요한 건 
몰입감 있는 재미있는 상호작용의 창조에 있다. 

물론 공개 엔진들이 많이 있긴 하지만 최고로 단순한 엔진을 하나 개발하여 다양한
시뮬레이션 모델을 테스트 해 보는 걸 목표로 했다. 렌더링, 애니메이션, 이펙트, 
파티클을 갖추고 PhysX와 OpenAL을 활용하여 물리와 사운드를 처리할 계획이다. 

\subsection{렌더링}

 
\chapter{서버 프레임워크}

\section{기반 구조}

MMOG (Massive Multiplayer Online Games)에서 요구하는 서버의 기반 구조가 
달성해야 할 목표는 다음과 같이 나누어 볼 수 있다. 

\begin{itemize}
\item 안정성 (Stability)
\item 성능 (Performance)
\item 확장성 (Scalability)
\item 빠른 동기화 (Synchronization)
\item 쉽고 빠른 개발
\end{itemize}

위 네 가지 목표를 달성하기 위한 기술은 시간에 따라 변화 발전하지만 현재까지 
리서치한 결과로는 다음과 같이 나누어 볼 수 있다. 

\begin{itemize}
\item 처리 구조 (Processing Model)
\item 통신 구조 (Communication Model)
\item 분산 구조 (Distribution Model)
\item 월드 구조 (World Model)
\item 시뮬레이션 구조 (Simulation Model)
\item 영속성 처리 구조 (Persistency Model)
\end{itemize}

각 영역별 과제와 해결 방향을 살펴보고 장단점을 비교 분석한다. 

\subsection{처리 구조}

서버의 처리 구조는 CPU 코어를 포함하여 16개 미만이 현재 일반적인 상황이다. 
다중 쓰레드를 사용하는 구조가 보편화되어 있으며 다중 쓰레드를 어떻게 
사용하는가에 따라 두 가지 정도로 나누어 생각할 수 있다. 

\subsubsection{대칭 구조}

대칭 구조란 여러 쓰레드가 월드의 부분을 동시에 실행하는 구조이다. 이런 접근 
방식은 항상 critical section에 대한 락을 걸어야 하며 락 충돌이 발생하면 
쓰레드 스위칭이 일어난다. 

대칭 구조는 다음과 같은 장점을 갖는다. 
\begin{itemize} 
\item 동시성을 최대한 올릴 수 있다
\item 데이터 복제나 이벤트 전파를 줄일 수 있다. 
\end{itemize}

하지만 다음과 같은 심각한 단점도 갖고 있다. 
\begin{itemize}
\item 락 처리가 까다로워진다. 
\item 코드 량이 늘어날수록, 시간이 지날수록 점점 느려진다.
\end{itemize}

대칭 구조의 장점을 유지하면서 락 처리를 프로그래머가 직접하지 않아도 
되는 구조에 대한 연구가 진행되고 있으며 DarkStar의 Java 서버 구현에서는
오브젝트에 대한 락을 미리 잡는 방식으로 피하고 있다. 하지만 엄청 느리다는
결정적인 단점이 있다. 

대칭 구조를 사용하여 여전히 개발하고 있으나 장기적으로 갖고 갈 방향은 아니라고 본다. 

\subsubsection{비대칭 구조}

비대칭 구조란 개별 쓰레드에서 처리하는 데이터, 월드를 분할하여 처리하는 
방식이다. 비대칭 구조는 메세지 패싱을 기본 아이디어로 삼고 있으며 이를 
계산 모델로 확립한 Actor 모델이 있다. Actor 모델은 분산 인공지능에 
적용된 Multi Agent System (MAS)의 기반 아이디어로 사용하고 있다. 

비대칭 구조로 MMOG를 만드는 것은 가능하며 다크에이지오브카멜롯, 메틴, 
썬 등에 사용되었고 넥슨의 둠바스도 이런 아이디어에 기초하고 있다. 

비대칭 구조의 장점은 다음과 같다. 
\begin{itemize}
\item 락 처리가 거의 필요 없다. (메세지 큐 정도에만 사용)
\item 시간이 지나도 성능이 떨어지지 않는다
\item 좀 더 세밀하게 분할하는 확장을 쉽게 할 수 있다
\end{itemize}

당연히 다음과 같은 단점도 있다. 
\begin{itemize}
\item 분할된 지역 기능에 대한 동시성을 올리기 어렵다
\item 각 분할 영역 간의 메세지, 데이터 전파가 필요하다
\end{itemize}

\subsubsection{처리 구조 정리}

DirectX11의 멀티 쓰레딩 구조나 기존의 쓰레드 기반 렌더러를 보면 command queue 방식을 
사용하고 있다. 렌더링 쓰레드, 물리 처리 쓰레드, 애플리케이션 쓰레드로 분할 하고 
각 쓰레드 간에 명령어를 주고 받아서 처리하는 방식이다. 

서버도 전체 월드를 지역별로 분할하고 각 지역을 좀 더 세분화 가능하게 만들고 
AI를 돌리는 쓰레드를 별도로 두는 방식으로 대칭 구조에 필적하는 성능을 
갖게 만들 수 있다. 

지금까지 경험으로 보면 이런 지역 분할 방식과 연계된 서버들은 모두 상당히 
안정적이며 유지보수도 쉽다. 

메세지 패싱을 사용하면 처리하는 쓰레드가 다른 장비에 있더라도 그대로 
적용 가능하기 때문에 가용한 CPU 수량을 늘리는 걸 거의 공짜로 할 수 있다. 

이런 장점을 활용하면 클라이언트 중의 하나가 특정 기능을 담당하도록 하는 
분산 기능도 쉽게 구현할 수 있다. 


\subsection{통신 구조}

통신은 이미 해결된 문제로 보인다. 지금까지 해결된 내용이 무엇인지만 
간결하게 살펴본다. 

\begin{itemize}
\item 대규모 통신 처리 지원 (IOCP, EPOLL, AIO 등)
\item TCP와 UDP 상의 통신 구조 
\item 패킷 암호화, 패킷 검증 (순서, 누락 등)
\item P2P 통신 처리 (홀 펀칭, Reliable UDP 등)
\end{itemize}

물론 게임을 만들다 보면 패치 시스템과 같은 전혀 다른 통신 구조를 
만들어야 하는 경우도 생긴다. 리소스 스트리밍은 게임 구현과는 
직접 연관이 없지만 서비스 품질을 올리는 데는 아주 중요하며 
서버 프로그래머가 클라이언트 프로그래머와 함께 해결해야 하는 과제이다. 

\subsection{분산 구조}

처리 구조와 어느 정도 연관되지만 서버의 장비들을 확장하거나 PC를 게임 
시뮬레이션에 직접적으로 활용하거나 (트래픽 전파나 물리 처리에 활용) 하는 
다른 차원의 분산 구조가 필요하다. 

일관성과 유일성을 보장해야 하는 길드 처리나 DB 처리는 한 곳에서 관리하는 게 
필요하다. 이런 기능들을 몰아두고 인증 정보 등을 관리하기 위한 구조로 대략
다음과 같은 서버 분산 구조를 채택한다. 

\begin{itemize}
\item 로비 서버를 두는 경우
\item 센터(백엔드) 서버를 두는 경우 
\end{itemize}



\subsection{월드 구조}



\subsection{시뮬레이션 구조}



\subsection{영속성 처리 구조}




\section{시뮬레이션}


\subsection{물리 기반의 월드}


\subsection{논리 기반의 월드}

\subsection{서버 AI}

\subsubsection{몬스터 AI}

\subsubsection{보드 게임 AI}


\subsection{일반적인 컨텐츠 구현 구조}

\subsubsection{인벤토리}


\subsubsection{퀘스트}

\subsubsection{파티}


\end{document}